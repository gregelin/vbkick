#!/bin/bash

# Copyright (c) 2013-2014, Kamil Wilas (wilas.pl)
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.

# Helps build Virtualbox guest VMs and Vagrant base boxes.

# Secure bash
# More about options: http://wiki.bash-hackers.org/commands/builtin/set
# treat unset variables as an error
set -u;
# exit when cmd fail (use ERR trap for clean exit)
set -e; set -E;
# fail the entire pipeline if any part of it fails
set -o pipefail;
# debug mode
#set -x;
# http://mywiki.wooledge.org/glob
shopt -s failglob;
# enable POSIX mode
# http://www.gnu.org/software/bash/manual/html_node/Bash-POSIX-Mode.html
set -o posix
# Turn off history expansion
set +o histexpand

# For nice printing
# NB. tput setaf 1; tput sgr0 is not portable, e.g. git-bash
_GREEN="\033[1;32m"
_RED="\033[1;31m"
_YELLOW="\033[1;33m"
_NORMAL="\033[0m"
__log_info() {
    printf "[INFO] %s\n" "${*}"
}
__log_ginfo() {
    printf "${_GREEN}[INFO] %s${_NORMAL}\n" "${*}"
}
__log_warning() {
    printf "${_YELLOW}[WARNING] %s${_NORMAL}\n" "${*}"
}
__log_error() {
    printf "${_RED}[ERROR] %s${_NORMAL}\n" "${*}" >&2
}

# default vm settings which may be overwritten by definition file
__load_default_settings() {
    # VM default settings - basic
    hostiocache="on"
    cpu_count=1
    memory_size=512
    disk_size=(10140)
    disk_format="vdi"
    video_memory_size=10
    # available boot devices: none|floppy|dvd|disk|net
    # there are four slots, if priovided less than 4, extra slots set to none
    # if provided more than 4, extra values are droped
    boot_order=("disk" "dvd")
    # default nic type: Intel PRO/1000 MT Desktop (82540EM); recommended - virtio
    # more to choose Am79C970A|Am79C973|82540EM|82543GC|82545EM|virtio
    # http://www.virtualbox.org/manual/ch06.html#nichardware
    nic_type="82540EM"
    # list of VM options: ("option1:value" "option2:value")
    vm_options=("ioapic:on")
    # list of VM extradata to set: ("extradata:value" "extradata:value")
    vm_extradata=("")
    # by default gui enabled unless the VirtualBox GUI is missing
    gui_enabled=1
    if ! command -v VirtualBox >/dev/null 2>&1; then
        gui_enabled=0
    fi
    # by default add one shared folder - to disable: shared_folders=("")
    shared_folders=("vbkick:%PWD%:automount")
    # by default no extra ports is mapping
    extra_ports=("")

    # Guest Additions default settings
    # set to 0 to not attach VBoxGuestAdditions iso to guest
    guest_additions_attach=1
    # path where guest_additions should be download, if empty then not download custom VBoxGuestAdditions to host, use default one
    guest_additions_path=""

    # Boot default settings
    #boot_file -> required option, fail if not in definition
    #boot_file_src -> required option, fail if not in definition
    # type of boot media e.g.: hdd, dvddrive; by default dvddrive
    boot_file_type="dvddrive"
    # default path for src media needed to create destination boot_file
    boot_file_src_path="iso"
    # by default checksum is empty - checksum is not check
    boot_file_src_checksum=""
    # default cheksum type is md5
    boot_file_checksum_type="md5"
    # by default unpacke is not needed
    boot_file_unpack_cmd=""
    # where is the path and the filename after unpack
    boot_file_unpack_name=""
    # is boot_file_src raw image and need to be converted
    boot_file_convert_from_raw=0
    # whether use cp or mv when boot_file is created form boot_file_src_file;
    # mv mean don't keep boot_file_src_file; keep only boot_file; by default 0 - use mv
    keep_boot_src_file=0
    # default time before boot_cmd_sequence start
    boot_wait=10
    # list of boot_cmd: ("cmd1" "cmd2" "cmd3")
    boot_cmd_sequence=("")
    # default number of second wait between each boot_cmd
    boot_seq_wait=1
    # default webserver port to serve kickstart files
    kickstart_port=7122
    # default max webserver live time
    kickstart_timeout=7200
    # do not start local webserver, by default 0 - mean start webserver to serve files from current dir.
    webserver_disabled=0

    # SSH default settings (veeded to run vbkick validate and/or lazy_posinstall)
    # by default use ssh keys
    ssh_keys_enabled=1
    # default user
    ssh_user="vbkick"
    # default user password - not use when ssh_keys authentication is enabled
    ssh_password="vbkick"
    # default path to ssh keys
    ssh_keys_path="keys"
    # default private key name
    ssh_priv_key="vbkick_key"
    # default auto-download path
    ssh_priv_key_src="https://raw.github.com/wilas/vbkick/master/keys/vbkick_key"
    # default ssh host port
    ssh_host_port=2222
    # default (22) ssh guest port to forwarding
    ssh_guest_port=22
    # default "vbkickSSH"
    ssh_port_name="vbkickSSH"
    # default extra ssh and scp options
    # UserKnownHostsFile - database file to use for storing the user host keys
    # StrictHostKeyChecking - if "no" then automatically add new host keys to the host key database file
    # you may consider editing ssh config: http://superuser.com/questions/141344/ssh-dont-add-hostkey-to-known-hosts
    ssh_options="-o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o NumberOfPasswordPrompts=1"

    # Export default settings
    # by default export file to the current directory with name base on the VM name
    export_file="./%NAME%.box"

    # Lazy Postinstall default settings
    # list of files and directories to transport to guest
    postinstall_transport=("")
    # list of postinstall commands
    postinstall_launch=("")

    # Validate default settings
    # list of files and directories to transport to guest
    validate_transport=("")
    # list of validate commands
    validate_launch=("")

    # Lazy Update default settings
    # list of files and directories to transport to guest
    update_transport=("")
    # list of update commands
    update_launch=("")

    # Play default settings
    # list of files and directories to transport to guest
    play_transport=("")
    # list of play commands
    play_launch=("")

    # Clean
    # list of files to autoupdate VBOX_VERSION value
    files_to_autoupdate_vbox_version=("")
    # rm or not already transported via SCP files/directories (from postinstall, validate)
    clean_transported=0
    # nice for OS shutdown command, if not specify acpipowerbutton will be used
    shutdown_cmd=""
    # when timeout is reached and VM is still running, hard poweroff is used
    shutdown_timeout=20
}

# Global variables - do not use it in definition file (will be overwrite during program runtime)
# name of global "private" variables should start with underscore
__init_global_state_variables(){
    # 0 - webserver is not running or kill isn't able to stop it
    _webserver_state=0
    # 0 - webserver was killed cleanly or we didn't try kill it yet
    _webserver_kill_cmd_state=0
    # during exporting tmp directory is created
    _tmp_dir=""
    # during creation VM may be temporary in inconsistent state
    # e.g. not all ports mapping, options etc. were setup
    # this flag is used to make sure that vm was created completely or not at all
    _vm_creation_state=0
    # during exporting NAT mapping is removed (temporary) - help recover state before exporting
    _ssh_natmapping_was_removed=0
    # during exporting shared folders are removed (temporary) - help recover state before exporting
    _sharedfolders_removed_ptr=0
    # during exporting extra ports are removed (temporary) - help recover state before exporting
    _extraports_removed_ptr=0
}

# Display help
#@action
_usage() {
    printf "%b" "Description: the automatic Virtualbox Guests and Vagrant Base Boxes builder\n"
    printf "%b" "\n"
    printf "%b" "Usage: vbkick <command> <VM_NAME> [<args>]\n"
    printf "%b" "\tversion               Print the version and exit\n"
    printf "%b" "\thelp                  Print this help\n"
    printf "%b" "\n"
    printf "%b" "Common commands:\n"
    printf "%b" "\tbuild                 Build the new VM\n"
    printf "%b" "\tpostinstall           Run postinstall scripts via SSH\n"
    printf "%b" "\tplay                  Run play commands via SSH\n"
    printf "%b" "\tvalidate              Run validate scripts via SSH\n"
    printf "%b" "\tupdate                Run update scripts via SSH\n"
    printf "%b" "\texport                Exports the VM and creates a Vagrant box - VM_NAME.box\n"
    printf "%b" "\tdestroy               Shut down and deletes the VM\n"
    printf "%b" "\tssh                   Connect to the VM via SSH\n"
    printf "%b" "\ton                    Turn on the VM\n"
    printf "%b" "\tshutdown              Shut down the VM\n"
    printf "%b" "\tclone                 Clone the VM\n"
    printf "%b" "\tlssnap                List all snapshots for a given VM\n"
    printf "%b" "\tsnap                  Take a new VM snapshot\n"
    printf "%b" "\tresnap                Restore the VM snapshot\n"
    printf "%b" "\tdelsnap               Delete the VM snapshot\n"
    printf "%b" "\tlist                  List all VirtualBox machines with the state\n"
    printf "%b" "\n"
    printf "%b" "For help on any individual command run 'vbkick <command> -h'\n"
    printf "%b" "\n"
}

#@action
_context_usage(){
    case "${1}" in
        "build")
            printf "%b" "Usage: vbkick build <VM_NAME> [definition_file]\n"
            printf "%b" "If no definition file specify 'vbmachine.cfg' is used.\n" ;;
        "destroy")
            printf "%b" "Usage: vbkick destroy <VM_NAME>\n" ;;
        "export")
            printf "%b" "Usage: vbkick export <VM_NAME> [definition_file]\n"
            printf "%b" "If no definition file specify 'vbmachine.cfg' is used.\n" ;;
        "validate")
            printf "%b" "Usage: vbkick validate <VM_NAME> [definition_file]\n"
            printf "%b" "If no definition file specify 'vbmachine.cfg' is used.\n" ;;
        "postinstall")
            printf "%b" "Usage: vbkick postinstall <VM_NAME> [definition_file]\n"
            printf "%b" "If no definition file specify 'vbmachine.cfg' is used.\n" ;;
        "play")
            printf "%b" "Usage: vbkick play <VM_NAME> [definition_file]\n"
            printf "%b" "If no definition file specify 'vbmachine.cfg' is used.\n" ;;
        "update")
            printf "%b" "Usage: vbkick update <VM_NAME> [definition_file]\n"
            printf "%b" "If no definition file specify 'vbmachine.cfg' is used.\n" ;;
        "ssh")
            printf "%b" "Usage: vbkick ssh <VM_NAME> [definition_file]\n"
            printf "%b" "If no definition file specify 'vbmachine.cfg' is used.\n" ;;
        "on")
            printf "%b" "Usage: vbkick on <VM_NAME> [definition_file]\n"
            printf "%b" "If no definition file specify 'vbmachine.cfg' is used.\n" ;;
        "shutdown")
            printf "%b" "Usage: vbkick shutdown <VM_NAME> [definition_file]\n"
            printf "%b" "If no definition file specify 'vbmachine.cfg' is used.\n" ;;
        "clone")
            printf "%b" "Usage: vbkick clone <VM_NAME> [clone_name]\n"
            printf "%b" "If no clone name specify default one will be used - {VM_NAME}-clone{NR},\n"
            printf "%b" "where {NR} is the next available number.\n" ;;
        "snap")
            printf "%b" "Usage: vbkick snap <VM_NAME> [snapshot_name]\n"
            printf "%b" "If no snapshot name specify default one will be used - {VM_NAME}-snap{NR},\n"
            printf "%b" "where {NR} is the next available number.\n" ;;
        "resnap")
            printf "%b" "Usage: vbkick resnap <VM_NAME> [snapshot_name]\n"
            printf "%b" "If no snapshot name specify, restore to the current snapshot.\n" ;;
        "delsnap")
            printf "%b" "Usage: vbkick delsnap <VM_NAME> [snapshot_name]\n"
            printf "%b" "If no snapshot name specify, delete the current snapshot.\n" ;;
        "lssnap")
            printf "%b" "Usage: vbkick lssnap <VM_NAME>\n" ;;
        "list")
            printf "%b" "Usage: vbkick list\n" ;;
        *) _usage; exit ;;
    esac
}

#@special
_process_2_args() {
    # 2 args are required, 3 may be optional
    if [[ "${2}" == "-h" ]] || [[ "${3:-}" == "-h" ]]; then
        _context_usage "${1}"
        exit 0
    fi
    _Vm="${2}"
    case "${1}" in
        "build") _build_vm "${3:-}" ;;
        "destroy") _destroy_vm ;;
        "export") _export_vm "${3:-}" ;;
        "validate") _validate_vm "${3:-}" ;;
        "postinstall") _lazy_postinstall "${3:-}" ;;
        "play") _lazy_play "${3:-}" ;;
        "update") _lazy_update "${3:-}" ;;
        "ssh") _lazy_ssh "${3:-}" ;;
        "on") _turn_on "${3:-}" ;;
        "shutdown") _turn_off "${3:-}" ;;
        "clone") _make_clone "${3:-}" ;;
        "snap") _take_snapshot "${3:-}" ;;
        "resnap") _restore_snapshot "${3:-}" ;;
        "delsnap") _delete_snapshot "${3:-}" ;;
        "lssnap") _list_snapshots ;;
        *) _usage; exit ;;
    esac
}

#@special
_process_1_args() {
    # 1 arg is required
    case "${1}" in
        "list") _list_all_vms ;;
        "version") _prog_version ;;
        *) _usage; exit ;;
    esac
}

#@action
_prog_version(){
    printf "%b" "0.8.0-dev\n"
    exit 0
}

#@action
_list_all_vms(){
    local __lc_vm
    local __lc_state
    #list all vms and remove trailing spaces from the __lc_vm name
    "${_VBoxManage}" list vms | cut -f 1 -d'{' | sed 's/[ ]*$//g' | while read -r __lc_vm; do
        # get the pure __lc_vm name: "aa bb" -> aa bb
        __lc_vm="${__lc_vm//\"/}"
        # Example showvminfo output: "State:           powered off (since 2014-04-28T00:16:26.000000000)"
        # get only the state value and trim leading and trailing spaces
        __lc_state=$("${_VBoxManage}" showvminfo "${__lc_vm}" | grep "State:" | cut -d' ' -f 2- | cut -d'(' -f 1 | sed 's/[ ]*$//g;s/^[ ]*//g')
        printf "%b" "${__lc_vm}:${__lc_state}\n"
    done
    exit 0
}

# Help automatically update/maintain value of VBOX_VERSION in given files list
__autoupdate_files_with_vbox_version() {
    local __file
    for __file in "${files_to_autoupdate_vbox_version[@]}"; do
        # check whether __file is an empty string
        if [[ -z "${__file}" ]]; then
            continue
        fi
        # check whether __file exist
        if [[ -f "${__file}" ]]; then
            # example value to update: VBOX_VERSION="4.2.12", but ignore comments
            sed -i'' -e "/^#/"'!'"s/\(VBOX_VERSION\)=\"\([0-9.][0-9.]*\)\"/\1=\"${_vb_version}\"/g" "${__file}"
        else
            printf "%b" "VBOX_VERSION=\"${_vb_version}\"\n" > "${__file}"
            printf "%b" "export VBOX_VERSION\n" >> "${__file}"
        fi
    done
}

__depend_check() {
    local __dep_cmd="${1}"
    local __dep_name="${2}"
    # check whether __dep_name is installed - __dep_cmd command exist
    if ! command -v ${__dep_cmd} >/dev/null 2>&1; then
        __log_error "${__dep_cmd} command doesn't exist - install '${__dep_name}' to continue."
        return 1
    fi
}

__dependencies_check() {
    __depend_check "${_VBoxManage}" "Virtualbox"
    __depend_check "curl" "curl"
    __depend_check "ssh" "ssh-client (e.g. openssh-client)"
    __depend_check "scp" "scp-client (e.g. openssh-client)"
    __depend_check "perl" "perl"
    __depend_check "bash" "bash"
    __depend_check "openssl" "openssl"
    __depend_check "sed" "sed"
    __depend_check "grep" "grep"
    __depend_check "mktemp" "coreutils"
    __depend_check "cut" "coreutils"
    __depend_check "sort" "coreutils"
    __depend_check "tail" "coreutils"
    __depend_check "basename" "coreutils"
    __depend_check "dirname" "coreutils"
}

__check_required_settings() {
    local __opts=("boot_file" "boot_file_src" "os_type_id")
    local __opt
    for __opt in "${__opts[@]}"; do
        # evaluates to the null if value of __opt is unset and substitutes the string "x" otherwise
        if [[ -z "${!__opt+x}" ]]; then
            __log_error "Required ${__opt} option is not defined."
            return 1
        fi
    done
}

# Every action which requires vm settings must use this function to load them.
__load_definition() {
    __load_default_settings
    # vbmachine.cfg is a default definition file
    # loading definition file overwrite default settings
    local __definition_fname="${1:-vbmachine.cfg}"
    if [[ -s "${__definition_fname}" ]]; then
        # In POSIX mode the '.' and 'source' builtins do not search the current directory
        # for the filename argument if it is not found by searching PATH.
        __log_info "Loading '${__definition_fname}' definition..."
        if ! . "./${__definition_fname}"; then
            __log_error "Loading failed."
            return 1
        fi
    else
        __log_error "Not existing or empty '${__definition_fname}' file in $(pwd). Terminating..."
        return 1
    fi
    # if someone overwrite them in definition file
    __init_global_state_variables
    _vb_version=$(__get_vb_version)
    __check_required_settings
    __autoupdate_files_with_vbox_version
}

# Get virtualbox version
__get_vb_version() {
    local __version=$("${_VBoxManage}" --version) # e.g. 4.2.12r84980
    __version=$(printf "%b" "${__version}\n" | sed -n 's/\([0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\).*/\1/p')
    #__version=$(printf "%b" "${__version}\n" | sed 's/\([0-9][0-9]*\.[0-9][0-9]*\.[0-9][0-9]*\).*/\1/p' | tail -1)
    printf "%b" "${__version}"
}

__is_present() {
    local __pattern="${1:-\"${_Vm}\"}"
    "${_VBoxManage}" list vms | grep -w "${__pattern}" > /dev/null
}

__is_running() {
    "${_VBoxManage}" showvminfo "${_Vm}" | grep "State:[ ][ ]*running" > /dev/null
}

__is_powered_off() {
    "${_VBoxManage}" showvminfo "${_Vm}" | grep "State:[ ][ ]*powered off" > /dev/null
}

__is_paused() {
    "${_VBoxManage}" showvminfo "${_Vm}" | grep "State:[ ][ ]*paused" > /dev/null
}

__is_alive() {
    # Alive machine may be in paused|running state
    # Useful to change state: "${_VBoxManage}" controlvm "${_Vm}" pause|resume
    local __pattern="${1:-\"${_Vm}\"}"
    "${_VBoxManage}" list runningvms | grep -w "${__pattern}" > /dev/null
}

__is_port_used() {
    local __port_nr="${1}"
    # () is useful to be silent
    (printf "%s" "" > /dev/tcp/127.0.0.1/${__port_nr}) 2>/dev/null
}

__is_port_present() {
    local __port_name="${1}"
    "${_VBoxManage}" showvminfo "${_Vm}" | grep -w 'guest port' | grep -w "${__port_name}" > /dev/null
}

__is_shared_folder_present() {
    local __folder_name="${1}"
    "${_VBoxManage}" showvminfo "${_Vm}" | grep -w 'machine mapping' | grep -w "Name: '${__folder_name}'" > /dev/null
}

__is_snapshot_present() {
    local __snap_name="${1}"
    "${_VBoxManage}" snapshot "${_Vm}" list --machinereadable | grep -w "^SnapshotName\|SnapshotUUID" | grep -w "${__snap_name}" > /dev/null
}

__has_snapshots() {
    "${_VBoxManage}" snapshot "${_Vm}" list --machinereadable | grep -w "^SnapshotName" > /dev/null
}

# checks whether port is not used by other proc
__check_port_usage() {
    local __port_nr="${1}"
    local __port_message="${2}"
    if __is_port_used ${__port_nr}; then
        __log_error "${__port_nr} port (${__port_message}) is already used by an other process."
        return 1
    fi
}

# Check whether given directory exist
__prepare_path() {
    local __path="${1}"
    local __mkdir_path="${2}"
    # Process special variables in path definition e.g. __path="%VBOXFOLDER%/%NAME%"
    local __location=$("${_VBoxManage}" list  systemproperties | grep "Default machine folder" | cut -d':' -f 2- | sed 's/^[ ]*//g')
    __path=$(printf "%s" "${__path}" | sed "s|%SRCPATH%|${boot_file_src_path}|g")
    __path=$(printf "%s" "${__path}" | sed "s|%VBOXFOLDER%|${__location}|g")
    __path=$(printf "%s" "${__path}" | sed "s|%PWD%|$(pwd)|g")
    # get homedir - $(getent passwd UID) doesn't work for MacOS; $HOME is less portable than ~
    __path=$(printf "%s" "${__path}" | sed "s|%HOME%|~|g")
    __path=$(printf "%s" "${__path}" | sed "s|%NAME%|${_Vm}|g")
    # expand a special variable - e.g. tilde (~) and
    # strips out > characters which could clobber a file during the eval
    __path=$(eval echo "${__path//>}")
    # Creates dir if necessary
    if [[ ${__mkdir_path} -eq 1 ]] && [[ ! -z "${__path}" ]] && [[ ! -d "${__path}" ]]; then
        mkdir -p "${__path}"
    fi
    # Return __path
    printf "%s" "${__path}"
}

__curl_safe() {
    local __src="${1}"
    local __dest="${2}"
    local __statuscode=$(curl -Lkfw "%{http_code}\n" "${__src}" -o "${__dest}")
    if [[ ${__statuscode} -ne 200 ]]; then
        __log_error "${__src} status code is ${__statuscode}. Terminating..."
        return 1
    fi
}

# Downloads custom VBoxGuestAdditions if required
__download_guest_additions_media() {
    if [[ -z "${guest_additions_path}" ]]; then
        # nothing to do
        return
    fi
    guest_additions_path=$(__prepare_path "${guest_additions_path}" 1)
    # check whether VBoxGuestAdditions exist
    if [[ ! -f "${guest_additions_path}/VBoxGuestAdditions_${_vb_version}.iso" ]]; then
        local __additions_url="http://download.virtualbox.org/virtualbox/${_vb_version}/VBoxGuestAdditions_${_vb_version}.iso"
        __curl_safe "${__additions_url}" "${guest_additions_path}/VBoxGuestAdditions_${_vb_version}.iso"
    fi
    # rm useless images
    __remove_guest_additions_media
}

# Remove other (not needed) VBoxGuestAdditions from media directory
__remove_guest_additions_media() {
    if [[ -z "${guest_additions_path}" ]]; then
        # nothing to do
        return
    fi
    guest_additions_path=$(__prepare_path "${guest_additions_path}" 0)
    # true is use to not fail whole cmd, and return empty string
    local __file_list=$(ls "${guest_additions_path}" | grep "GuestAdditions" | grep -v "${_vb_version}" || true)
    # continue only if we have some files to remove
    if [[ -z "${__file_list}" ]]; then
        return
    fi
    __log_info "List of VBoxGuestAdditions files to remove:"
    local __file
    for __file in ${__file_list}; do
        printf "%b" "${guest_additions_path}/${__file}\n"
    done
    # to remove files ask about confirmation
    local __ans
    read -r -p "Do you want remove above VBoxGuestAdditions files? [y/N]" __ans
    if [[ ${__ans} =~ ^[Yy]$ ]]; then
        for __file in ${__file_list}; do
            printf "%b" "${guest_additions_path}/${__file}\n"
            rm -f "${guest_additions_path}/${__file}"
        done
    fi
}

# Prepare installation/boot media
__download_boot_media() {
    local __boot_file_path=$(dirname "${boot_file}")
    local __boot_file_name=$(basename "${boot_file}")
    __boot_file_path=$(__prepare_path "${__boot_file_path}" 1)
    boot_file="${__boot_file_path}/${__boot_file_name}"

    # the temporary name for boot_file is last part from boot_file_src
    local __tmp_name=$(basename "${boot_file_src}")
    boot_file_src_path=$(__prepare_path "${boot_file_src_path}" 1)
    local __boot_file_src_file="${boot_file_src_path}/${__tmp_name}"

    # check whether boot file exist
    if [[ -f "${boot_file}" ]]; then
        # if boot_file is the same as __boot_file_src_file then we can verify checksum
        # NB: In definition provided is checksum for the boot_file_src which may be a different
        # than destination boot_file
        if [[ "${boot_file}" == "${__boot_file_src_file}" ]]; then
            __verify_boot_media_checksum "${boot_file}"
        fi
        # file exist, nothing to do
        return
    fi

    # boot_file_src is empty (not defined)
    if [[ -z "${boot_file_src}" ]]; then
        __log_error "${boot_file} not exist and boot_file_src is empty"
        return 1
    fi

    # check whether boot_file_src exist
    if [[ ! -f "${__boot_file_src_file}" ]]; then
        __curl_safe "${boot_file_src}" "${__boot_file_src_file}"
    fi
    __verify_boot_media_checksum "${__boot_file_src_file}"

    # process unpack
    if [[ ! -z "${boot_file_unpack_cmd}" ]]; then
        __unpack_boot_media
        __boot_file_src_file="${boot_file_unpack_name}"
    fi

    __deploy_boot_media_file "${__boot_file_src_file}"
}

__verify_boot_media_checksum(){
    local __boot_file_src_file="${1}"
    # verify boot_file_src checksum if boot_file_src_checksum is provided
    if [[ -z "${boot_file_src_checksum}" ]]; then
        return
    fi
    # NB. openssl always returns 0 even if command fail e.g. not supporting digest command
    local __get_checksum=$(openssl "${boot_file_checksum_type}" "${__boot_file_src_file}" | cut -d" " -f 2)
    if [[ "${boot_file_src_checksum}" != "${__get_checksum}" ]]; then
        __log_warning "CHECKSUM is different than expected !"
        local __ans
        read -r -p "Do you want continue? [y/N]" __ans
        if [[ ! ${__ans} =~ ^[Yy]$ ]]; then
            return 1
        fi
    else
        __log_info "CHECKSUM:${boot_file_src_checksum} is valid."
    fi
}

__unpack_boot_media(){
    # check whether boot_file_unpack_name is empty if so then error
    if [[ -z "${boot_file_unpack_name}" ]]; then
        __log_error "boot_file_unpack_name is empty, but boot_file_unpack_cmd is specify"
        return 1
    fi
    # prepare path - this is full path, must already exist in filesystem
    boot_file_unpack_name=$(__prepare_path "${boot_file_unpack_name}" 0)
    # check whether boot_file_unpack_name exist - if not then run unpack cmd
    if [[ ! -f "${boot_file_unpack_name}" ]]; then
        # prepare and run unpack cmd
        boot_file_unpack_cmd=$(__prepare_path "${boot_file_unpack_cmd}" 0)
        __log_info "${boot_file_unpack_cmd}"
        eval "${boot_file_unpack_cmd}"
    fi
}

__deploy_boot_media_file(){
    local __boot_file_src_file="${1}"
    # process convert from raw if necessary
    if [[ ${boot_file_convert_from_raw} -eq 1 ]]; then
        "${_VBoxManage}" convertfromraw "${__boot_file_src_file}" "${boot_file}" --format "${disk_format}"
        if [[ ${keep_boot_src_file} -eq 0 ]]; then
            rm -f "${__boot_file_src_file}"
        fi
    else
        # check whether full path to __boot_file_src_file is same as boot_file and boot_file was already created
        if [[ -f "${boot_file}" ]]; then
            return
        fi
        # check whether cp or mv; mv mean don't keep __boot_file_src_file; keep only boot_file
        if [[ ${keep_boot_src_file} -eq 0 ]]; then
            mv -f "${__boot_file_src_file}" "${boot_file}"
        else
            cp "${__boot_file_src_file}" "${boot_file}"
        fi
    fi
}

# Prepare ssh keys
__get_priv_ssh_key() {
    # check whether keys dir exist
    if [[ ! -d "${ssh_keys_path}" ]]; then
        __log_info "Creates vbkick ssh keys directory"
        mkdir "${ssh_keys_path}"
    fi
    # check whether private key exist
    if [[ ! -f "${ssh_keys_path}/${ssh_priv_key}" ]]; then
        __curl_safe "${ssh_priv_key_src}" "${ssh_keys_path}/${ssh_priv_key}"
    fi
    # change ssh key permissions - too open private key will be ignored
    chmod 600 "${ssh_keys_path}/${ssh_priv_key}"
}

#@action
_build_vm() {
    # check whether VM already exist
    if __is_present; then
        __log_error "'${_Vm}' already exist"
        exit 1
    fi
    # load vm description/definition
    local __definition_fname="${1:-}"
    __load_definition "${__definition_fname}"
    # check SSH port usage
    __check_port_usage ${ssh_host_port} "SSH host"
    # start simple webserver (in background)
    __start_web_server
    # download boot/iso files
    __download_boot_media
    __download_guest_additions_media
    # create VM box with given settings
    __create_box
    # host ip to connect from guest
    local __host_ip=10.0.2.2
    # start VM
    if [[ ${gui_enabled} -eq 1 ]]; then
        "${_VBoxManage}" startvm --type gui "${_Vm}"  && sleep ${boot_wait}
    else
        "${_VBoxManage}" startvm --type headless "${_Vm}" && sleep ${boot_wait}
    fi
    # boot VM machine
    __log_info "Sending keyboard scancodes:"
    local __boot_cmd
    for __boot_cmd in "${boot_cmd_sequence[@]}"; do
        if [[ -z "${__boot_cmd}" ]]; then
            continue
        fi
        __boot_cmd=$(printf "%s" "${__boot_cmd}" | sed "s|%IP%|${__host_ip}|g")
        __boot_cmd=$(printf "%s" "${__boot_cmd}" | sed "s|%PORT%|${kickstart_port}|g")
        __boot_cmd=$(printf "%s" "${__boot_cmd}" | sed "s|%NAME%|${_Vm}|g")
        __log_info "${__boot_cmd}"
        # send string to the VM via external perl script
        # %s is needed to type e.g. \n literally not as a new line
        printf "%s" "${__boot_cmd}" | vbtyper.pm "${_Vm}"
        sleep ${boot_seq_wait}
    done

    # wait until machine will be ready (ssh connection start working) or timeout was reached
    __kickstart_monitoring

    # stop webserver
    __stop_web_server

    exit 0
}

__create_box() {
    # Register vm
    "${_VBoxManage}" createvm --name "${_Vm}" --ostype "${os_type_id}" --register
    _vm_creation_state=1

    # Creates disks
    # Get default location for disks
    local __location=$("${_VBoxManage}" list systemproperties | grep "Default machine folder" | cut -d':' -f 2- | sed 's/^[ ]*//g')

    # SATA controller - place for hdd and iso files
    # SATA controller allow add 30 disks, but vbkick reserve port 0 for boot media and port 1 for guest additions
    # check disk_size lenght
    if [[ ${#disk_size[@]} -gt 28 ]]; then
        __log_error "Too many disks in disk_size (limited to 28 disks)"
        return 1;
    fi
    if [[ "${_vb_version}" > "4.3.0" ]] || [[ "${_vb_version}" == "4.3.0" ]]; then
        "${_VBoxManage}" storagectl "${_Vm}" --name "SATA Controller"\
        --add sata --hostiocache ${hostiocache} --portcount $((${#disk_size[@]}+2))
    else
        "${_VBoxManage}" storagectl "${_Vm}" --name "SATA Controller"\
        --add sata --hostiocache ${hostiocache} --sataportcount $((${#disk_size[@]}+2))
    fi
    # SATA controller - add boot media
    "${_VBoxManage}" storageattach "${_Vm}" --storagectl "SATA Controller"\
    --type "${boot_file_type}" --port 0 --device 0 --medium "${boot_file}"
    # SATA controller - create and add hdd disks
    local __port_nr=2
    local __disk
    for __disk in "${disk_size[@]}"; do
        if [[ -z "${__disk}" ]]; then
            continue
        fi
        "${_VBoxManage}" createhd --filename "${__location}/${_Vm}/${_Vm}-${__port_nr}.${disk_format}"\
        --size ${__disk} --format "${disk_format}" --variant Standard
        "${_VBoxManage}" storageattach "${_Vm}" --storagectl "SATA Controller"\
        --port ${__port_nr} --device 0 --type hdd --medium "${__location}/${_Vm}/${_Vm}-${__port_nr}.${disk_format}"
        __port_nr=$((__port_nr+1))
    done
    # SATA controller - add VBoxGuestAdditions iso
    if [[ ${guest_additions_attach} -eq 1 ]]; then
        if [[ ! -z "${guest_additions_path}" ]]; then
            # custom VBoxGuestAdditions
            "${_VBoxManage}" storageattach "${_Vm}" --storagectl "SATA Controller"\
            --type dvddrive --port 1 --device 0 --medium "${guest_additions_path}/VBoxGuestAdditions_${_vb_version}.iso"
        else
            # default VBoxGuestAdditions
            "${_VBoxManage}" storageattach "${_Vm}" --storagectl "SATA Controller"\
            --type dvddrive --port 1 --device 0 --medium emptydrive
            "${_VBoxManage}" storageattach "${_Vm}" --storagectl "SATA Controller"\
            --type dvddrive --port 1 --device 0 --medium additions
        fi
    fi

    # Tuning VM
    # setting cpu's
    "${_VBoxManage}" modifyvm "${_Vm}" --cpus ${cpu_count}
    # setting memory size
    "${_VBoxManage}" modifyvm "${_Vm}" --memory ${memory_size}
    # setting video memory size
    "${_VBoxManage}" modifyvm "${_Vm}" --vram ${video_memory_size}
    # setting bootorder
    local __bo_idx=1
    local __bo
    for __bo in "${boot_order[@]}"; do
        if [[ -z "${__bo}" ]]; then
            "${_VBoxManage}" modifyvm "${_Vm}" --boot${__bo_idx} none
        else
            "${_VBoxManage}" modifyvm "${_Vm}" --boot${__bo_idx} ${__bo}
        fi
        local __bo_idx=$((__bo_idx+1))
        if [[ ${__bo_idx} -eq 5 ]]; then
            break
        fi
    done
    local __i
    for ((__i=${__bo_idx}; __i<=4; __i++)); do
        "${_VBoxManage}" modifyvm "${_Vm}" --boot${__i} none
    done
    # setting networking
    "${_VBoxManage}" modifyvm "${_Vm}" --nic1 nat --nictype1 ${nic_type} --cableconnected1 on
    # other settings
    local __option
    for __option in "${vm_options[@]}"; do
        if [[ -z "${__option}" ]]; then
            continue
        fi
        local __key="${__option%%:*}"
        local __value="${__option##*:}"
        "${_VBoxManage}" modifyvm "${_Vm}" --"${__key}" "${__value}"
    done
    # set extradata
    local __extradata
    for __extradata in "${vm_extradata[@]}"; do
        if [[ -z "${__extradata}" ]]; then
            continue
        fi
        local __key="${__extradata%%:*}"
        local __value="${__extradata##*:}"
        "${_VBoxManage}" setextradata "${_Vm}" "${__key}" "${__value}"
    done

    # ssh port NAT mapping; ssh port is a special one
    if ! __is_port_present "${ssh_port_name}"; then
        "${_VBoxManage}" controlvm "${_Vm}" natpf1 "${ssh_port_name},tcp,,${ssh_host_port},,${ssh_guest_port}"
    fi

    # extra ports NAT mapping
    __add_extra_ports_mapping "${extra_ports[@]}"

    # add shared folders
    __add_shared_folders "${shared_folders[@]}"
    _vm_creation_state=0
}

__add_extra_ports_mapping() {
    local __lc_extra_ports=("${@}")
    local __port
    for __port in "${__lc_extra_ports[@]}"; do
        if [[ -z "${__port}" ]]; then
            continue
        fi

        local IFS=':'
        local __port_info=(${__port})
        if [[ ${#__port_info[@]} -ne 3 ]]; then
            __log_error "one of the ports in extra_ports has invalid format."
            return 1
        fi
        local __port_name="${__port_info[0]}"
        local __port_host="${__port_info[1]}"
        local __port_guest="${__port_info[2]}"
        # add only if port doesn't exist
        if ! __is_port_present "${__port_name}"; then
            "${_VBoxManage}" controlvm "${_Vm}" natpf1 "${__port_name},tcp,,${__port_host},,${__port_guest}"
        fi
    done
}

__remove_extra_ports_mapping() {
    local __lc_extra_ports=("${@}")
    local __port
    for __port in "${__lc_extra_ports[@]}"; do
        if [[ -z "${__port}" ]]; then
            # note which extra ports were removed by moving _extraports_removed_ptr
            _extraports_removed_ptr=$((_extraports_removed_ptr+1))
            continue
        fi

        local IFS=':'
        local __port_info=(${__port})
        if [[ ${#__port_info[@]} -ne 3 ]]; then
            __log_error "one of the ports in extra_ports has invalid format."
            return 1
        fi
        local __port_name="${__port_info[0]}"
        if __is_port_present "${__port_name}"; then
            "${_VBoxManage}" controlvm "${_Vm}" natpf1 delete "${__port_name}"
            # note which extra ports were removed by moving _extraports_removed_ptr
            _extraports_removed_ptr=$((_extraports_removed_ptr+1))
        fi
    done
}

__add_shared_folders() {
    local __lc_shared_folders=("${@}")
    local __folder
    for __folder in "${__lc_shared_folders[@]}"; do
        if [[ -z "${__folder}" ]]; then
            continue
        fi

        local IFS=':'
        local __folder_info=(${__folder})
        if [[ ${#__folder_info[@]} -lt 2 ]]; then
            __log_error "one of the folders in shared_folders has no info about path."
            return 1
        fi
        local __folder_name="${__folder_info[0]}"
        local __folder_path=$(__prepare_path "${__folder_info[1]}" 1)

        # check whether shared_folder already exist
        if __is_shared_folder_present "${__folder_name}"; then
            continue
        fi

        if [[ ${#__folder_info[@]} -eq 2 ]]; then
            __log_info "${_VBoxManage} sharedfolder add  '${_Vm}' --name '${__folder_name}' --hostpath '${__folder_path}'"
            "${_VBoxManage}" sharedfolder add "${_Vm}" --name "${__folder_name}" --hostpath "${__folder_path}"
        elif [[ ${#__folder_info[@]} -eq 3 ]]; then
            __log_info "${_VBoxManage} sharedfolder add  '${_Vm}' --name '${__folder_name}' --hostpath '${__folder_path}' --${__folder_info[2]}"
            "${_VBoxManage}" sharedfolder add "${_Vm}" --name "${__folder_name}" --hostpath "${__folder_path}" --"${__folder_info[2]}"
        elif [[ ${#__folder_info[@]} -eq 4 ]]; then
            __log_info "${_VBoxManage} sharedfolder add  '${_Vm}' --name '${__folder_name}' --hostpath '${__folder_path}' --${__folder_info[2]} --${__folder_info[3]}"
            "${_VBoxManage}" sharedfolder add "${_Vm}" --name "${__folder_name}" --hostpath "${__folder_path}" --"${__folder_info[2]}" --"${__folder_info[3]}"
        else
            __log_error "too much options in one of the shared_folders."
            return 1
        fi
    done
}

__remove_shared_folders() {
    local __lc_shared_folders=("${@}")
    local __folder
    for __folder in "${__lc_shared_folders[@]}"; do
        if [[ -z "${__folder}" ]]; then
            # note which shared folders were removed by moving _sharedfolders_removed_ptr
            _sharedfolders_removed_ptr=$((_sharedfolders_removed_ptr+1))
            continue
        fi

        local IFS=':'
        local __folder_info=(${__folder})
        if [[ ${#__folder_info[@]} -lt 2 ]]; then
            __log_error "one of the folders in shared_folders has no info about path."
            return 1
        fi
        if [[ ${#__folder_info[@]} -gt 4 ]]; then
            __log_error "too much options in one of the shared_folders."
            return 1
        fi
        local __folder_name="${__folder_info[0]}"
        if __is_shared_folder_present "${__folder_name}"; then
            "${_VBoxManage}" sharedfolder remove "${_Vm}" --name "${__folder_name}"
            # note which shared folders were removed by moving _sharedfolders_removed_ptr
            _sharedfolders_removed_ptr=$((_sharedfolders_removed_ptr+1))
        fi
    done
}

# Check whether machine was kickstarted before timeout
__kickstart_monitoring() {
    local __kickstart_counter=0
    local __extra_ssh_options="-o ConnectionAttempts=1 -o ConnectTimeout=1"
    # ssh key authentication enabled
    if [[ ${ssh_keys_enabled} -eq 1 ]]; then
        # create path to ssh private key
        __get_priv_ssh_key
        local __key_path="${ssh_keys_path}/${ssh_priv_key}"
        printf "%b" "\n"
        __log_info "Waiting ${kickstart_timeout} sec for login via SSH with user ${ssh_user} to 127.0.0.1:${ssh_host_port}"
        # wait until ssh start working (communication chanel with VM) or kickstart_timeout was reached
        while ! ssh "${ssh_user}@127.0.0.1" -q -t -i "${__key_path}" -p ${ssh_host_port} ${ssh_options} ${__extra_ssh_options} -C "echo"\
            && [[ ${__kickstart_counter} -le ${kickstart_timeout} ]]; do
            __kickstart_counter=$((__kickstart_counter+1))
            printf "%s" "."
            sleep 1
        done
        printf "%b" "\n"
    else
        # if no ssh key authentication enabled then wait until timeout will be reached
        __log_info "Sleeping ${kickstart_timeout} seconds ..."
        sleep ${kickstart_timeout}
    fi
}

#@action
_destroy_vm() {
    # check whether VM already exist
    if ! __is_present; then
        __log_error "'${_Vm}' doesn't exist"
        exit 1
    fi

    # destroy VM
    __log_info "Destroy '${_Vm}'"
    local __ans
    read -r -p "Are you sure? [y/N]" __ans
    if [[ ! ${__ans} =~ ^[Yy]$ ]]; then
        exit 1
    fi

    # check whether VM is alive
    if __is_alive; then
        __log_info "Poweroff '${_Vm}'"
        "${_VBoxManage}" controlvm "${_Vm}" poweroff
        sleep 1
    fi

    __log_info "Destroying '${_Vm}'..."
    "${_VBoxManage}" unregistervm "${_Vm}" --delete
    exit 0
}

#@action
_export_vm() {
    #
    # basic replacement for that vagrant command:
    # vagrant package --base "${_Vm}" --output "${_Vm}.box"
    # if more customisation required use: vagrant package (--help)
    #
    # tar command is required, check whether is installed
    __depend_check "tar" "tar"
    # load vm description/definition
    local __definition_fname="${1:-}"
    __load_definition "${__definition_fname}"

    # prepare export path
    local __export_file_path=$(dirname "${export_file}")
    local __export_file_name=$(basename "${export_file}")
    __export_file_path=$(__prepare_path "${__export_file_path}" 1)
    __export_file_name=$(__prepare_path "${__export_file_name}" 0)
    export_file="${__export_file_path}/${__export_file_name}"

    # check whether export_file already exist
    if [[ -f "${export_file}" ]]; then
        __log_error "'${export_file}' already exist."
        exit 1
    fi
    # check whether VM exist
    if ! __is_present; then
        __log_error "'${_Vm}' doesn't exist"
        exit 1
    fi
    # check whether VM is running and shutdown it
    __shutdown
    if ! __is_powered_off; then
        __log_error "'${_Vm}' is not powered off. Maybe has saved state."
        __log_error "You may need to run: \`vbkick on '${_Vm}'\` and \`vbkick shutdown '${_Vm}'\`"
        __log_error "To check '${_Vm}' state run: \`vbkick list | grep '${_Vm}:'\`"
        exit 1
    fi

    # clearing previously set port forwarding rules (only if exist)
    if __is_port_present "${ssh_port_name}"; then
        "${_VBoxManage}" controlvm "${_Vm}" natpf1 delete "${ssh_port_name}"
        _ssh_natmapping_was_removed=1
    fi

    # rm extra ports (only if exist)
    __remove_extra_ports_mapping "${extra_ports[@]}"

    # rm shared folder (only if exist)
    __remove_shared_folders "${shared_folders[@]}"

    # create _tmp_dir for export data
    # this is as well a check whether user has RW rights to __export_file_path
    _tmp_dir="$(TMPDIR="${__export_file_path}" mktemp -d  -t 'vbkick.XXXXXXXXXX')"
    # export VM to _tmp_dir
    "${_VBoxManage}" export "${_Vm}" --output "${_tmp_dir}/box.ovf"
    # get VM MAC Address
    local __mac_address=$("${_VBoxManage}" showvminfo --details --machinereadable "${_Vm}"\
    | grep "macaddress1" | cut -d"=" -f 2)
    # add Vagrantfile
    printf "%b" "Vagrant.configure(\"2\") do |config|
    \t# This Vagrantfile is auto-generated by \`vbkick export\` to contain
    \t# the MAC address of the box. Custom configuration should be placed in
    \t# the actual \`Vagrantfile\` in this box.
    \tconfig.vm.base_mac = ${__mac_address}
    end\n
    # Load include vagrant file if it exists after the auto-generated
    # so it can override any of the settings
    include_vagrantfile = File.expand_path(\"../include/_Vagrantfile\", __FILE__)
    load include_vagrantfile if File.exist?(include_vagrantfile)\n" > "${_tmp_dir}/Vagrantfile"
    # add metadata.json
    printf "%b" "{\"provider\":\"virtualbox\"}\n" > "${_tmp_dir}/metadata.json"
    # create VM_NAME.box (gzip) file
    pushd "${_tmp_dir}" > /dev/null
    tar -cvzf "${__export_file_name}" *
    popd > /dev/null
    mv "${_tmp_dir}/${__export_file_name}" "${__export_file_path}"
    # remove _tmp_dir
    rm -rf "${_tmp_dir}"
    # help recover some changes made on VM during exporting
    __recover_vm_state
    __log_info "Done: '${export_file}'"
    exit 0
}

__recover_vm_state() {
    # destroy VM as creation process was unsuccessful
    if [[ ${_vm_creation_state} -eq 1 ]]; then
        __log_info "Destroying not completed Virtual machine - '${_Vm}'"
        "${_VBoxManage}" unregistervm "${_Vm}" --delete
        _vm_creation_state=0
    fi
    # add NAT mapping after exporting - only if exist prev.
    if [[ ${_ssh_natmapping_was_removed} -eq 1 ]]; then
        "${_VBoxManage}" controlvm "${_Vm}" natpf1 "${ssh_port_name},tcp,,${ssh_host_port},,${ssh_guest_port}"
        _ssh_natmapping_was_removed=0
    fi
    # add extra ports after exporting - only if exist prev.
    if [[ ${_extraports_removed_ptr} -gt 0 ]]; then
        # add only folders which were removed, skip others (useful when SIGINT)
        local __lc_extra_ports=("${extra_ports[@]:0:${_extraports_removed_ptr}}")
        __add_extra_ports_mapping "${__lc_extra_ports[@]}"
        _extraports_removed_ptr=0
    fi
    # add shared folder after exporting - only if exist prev.
    if [[ ${_sharedfolders_removed_ptr} -gt 0 ]]; then
        # add only folders which were removed, skip others (useful when SIGINT)
        local __lc_shared_folders=("${shared_folders[@]:0:${_sharedfolders_removed_ptr}}")
        __add_shared_folders "${__lc_shared_folders[@]}"
        _sharedfolders_removed_ptr=0
    fi
}

#@action
_turn_on() {
    # check whether VM exist
    if ! __is_present; then
        __log_error "'${_Vm}' doese not exist. Use \`vbkick build '${_Vm}'\` to create the new VM."
        exit 1
    fi

    # check whether VM is already running
    if __is_running; then
        # nothing to do
        __log_ginfo "'${_Vm}' is already running..."
        exit 0
    elif __is_paused; then
        "${_VBoxManage}" controlvm "${_Vm}" resume
        __log_info "'${_Vm}' was resumed."
        exit 0
    fi

    # load vm description/definition - needed for gui or headless
    local __definition_fname="${1:-}"
    __load_definition "${__definition_fname}"

    if [[ ${gui_enabled} -eq 1 ]]; then
        "${_VBoxManage}" startvm --type gui "${_Vm}"
    else
        "${_VBoxManage}" startvm --type headless "${_Vm}"
    fi
    exit 0
}

#@action
_turn_off() {
    # check whether VM exist
    if ! __is_present; then
        __log_error "'${_Vm}' doese not exist. Use \`vbkick build '${_Vm}'\` to create the new VM."
        exit 1
    fi

    # check whether VM is alive
    if ! __is_alive; then
        __log_ginfo "'${_Vm}' is already turn off."
        exit 0
    fi

    # load vm description/definition
    local __definition_fname="${1:-}"
    __load_definition "${__definition_fname}"

    #exec shutdown
    __shutdown
    exit 0
}

__shutdown() {
    # check whether VM is running and exec shutdown_cmd via SSH
    if [[ -n "${shutdown_cmd}" ]]; then
        if __is_running; then
            __log_info "Shutting down '${_Vm}'."
            __fix_ssh_port
            __ssh_do_launch "${shutdown_cmd}"
            __shutdown_monitoring
            sleep 3
        fi
    fi

    # check whether VM is still running, if so use acpipowerbutton
    if __is_running; then
        "${_VBoxManage}" controlvm "${_Vm}" acpipowerbutton
        __log_info "Shutting down '${_Vm}' via acpipowerbutton."
        __shutdown_monitoring
        sleep 3
    fi

    # check whether VM is still alive (e.g. paused), if so poweroff it using hard way.
    if __is_alive; then
        "${_VBoxManage}" controlvm "${_Vm}" poweroff
        __log_info "'${_Vm}' was powered off."
        sleep 3
    fi
    if __is_powered_off; then
        __log_info "'${_Vm}' was shutdown cleanly."
    else
        __log_warning "'${_Vm}' has different than 'powered off' state."
    fi
}

__shutdown_monitoring() {
    # wait until VM is down or shutdown_timeout was reached
    local __shutdown_counter=0
    while __is_alive && [[ ${__shutdown_counter} -le ${shutdown_timeout} ]]; do
        __shutdown_counter=$((__shutdown_counter+1))
        printf "%s" "."
        sleep 1
    done
    printf "%b" "\n"
}

__update_guest_additions_media() {
    # check whether VM exist
    if ! __is_present; then
        __log_error "'${_Vm}' doesn't exist. Use \`vbkick build '${_Vm}'\` to create the new VM."
        return 1
    fi
    # get current guest version
    if "${_VBoxManage}" guestproperty enumerate "${_Vm}" | grep "GuestAdd/Version" > /dev/null; then
        # guest already exist, get current version
        local __guest_version=$("${_VBoxManage}" guestproperty get "${_Vm}" "/VirtualBox/GuestAdd/Version" | cut -f 2 -d " ")
    else
        # guest doesn't exist
        local __guest_version=""
    fi

    # check whether we need update or install VBoxGuestAdditions
    if [[ "${_vb_version}" == "${__guest_version}" ]]; then
        __log_ginfo "VBoxGuestAdditions on '${_Vm}' is up-to-date - update media iso is not needed."
        return
    fi
    # TODO [LOW]: use Storage Controller Name (1) and type to find controller name
    # check whether "SATA Controller (1, 0)" exist - require to attach iso and creates /dev/sr1 or /dev/sr0
    if ! "${_VBoxManage}" showvminfo "${_Vm}" | grep -w "SATA Controller (1, 0)" > /dev/null; then
        __log_error "'SATA Controller (1, 0)' for '${_Vm}' doesn't exist."
        __log_error "'SATA Controller' is sata controller name used by vbkick."
        __log_error "More: \`${_VBoxManage} showvminfo '${_Vm}' | grep -w 'Controller'\`"
        __log_error "To create proper controller use:"
        __log_error "\`${_VBoxManage} storagectl '${_Vm}' --name 'SATA Controller' --add sata --hostiocache ${hostiocache} --portcount $((${#disk_size[@]}+2))\`"
        __log_error "\`${_VBoxManage} storageattach '${_Vm}' --storagectl 'SATA Controller' --type dvddrive --port 1 --device 0 --medium emptydrive\`"
        __log_error "To do this '${_Vm}' must be shutdown !!!"
        __log_error "Remember - VM Guest may have only one sata controller."
        return 1
    fi
    # Attach new VBoxGuestAdditions to install
    # vbkick creates VM with SATA Controller port 1 available for VBoxGuestAdditions iso.
    if [[ ! -z "${guest_additions_path}" ]]; then
        # custom VBoxGuestAdditions
        __download_guest_additions_media
        "${_VBoxManage}" storageattach "${_Vm}" --storagectl "SATA Controller"\
        --type dvddrive --port 1 --device 0 --medium "${guest_additions_path}/VBoxGuestAdditions_${_vb_version}.iso" --forceunmount
    else
        # default VBoxGuestAdditions
        "${_VBoxManage}" storageattach "${_Vm}" --storagectl "SATA Controller"\
        --type dvddrive --port 1 --device 0 --medium additions --forceunmount
    fi
    # NB: Guest OS (Linux) does not support automatic Guest Additions updating:
    # "${_VBoxManage}" guestcontrol <vmname>|<uuid> updateadditions
    # Manuall Guest Additions update/installation is required (via _lazy_update cmd).
}

#@action
_validate_vm() {
    #
    # test should be smart enough to check what I really want to test
    # e.g. If I don't need chef, don't test whether I have chef
    #
    # load vm description/definition
    local __definition_fname="${1:-}"
    __load_definition "${__definition_fname}"
    # exec scripts on VM Guest via ssh
    __ssh_exec ${#validate_transport[@]} "${validate_transport[@]}" "${validate_launch[@]}"
    exit 0
}

#@action
_lazy_postinstall() {
    # load vm description/definition
    local __definition_fname="${1:-}"
    __load_definition "${__definition_fname}"
    # exec scripts on VM Guest via ssh
    __ssh_exec ${#postinstall_transport[@]} "${postinstall_transport[@]}" "${postinstall_launch[@]}"
    exit 0
}

#@action
_lazy_play() {
    # load vm description/definition
    local __definition_fname="${1:-}"
    __load_definition "${__definition_fname}"
    # exec scripts on VM Guest via ssh
    __ssh_exec ${#play_transport[@]} "${play_transport[@]}" "${play_launch[@]}"
    exit 0
}

#@action
_lazy_update() {
    # load vm description/definition
    local __definition_fname="${1:-}"
    __load_definition "${__definition_fname}"
    # Check whether VBoxGuestAdditions should be installed. If not then not update additions.
    if [[ ${guest_additions_attach} -eq 1 ]]; then
        __update_guest_additions_media
    fi
    # Run other update scripts on VM Guest via ssh
    __ssh_exec ${#update_transport[@]} "${update_transport[@]}" "${update_launch[@]}"
    exit 0
}

__ssh_exec() {
    #
    # transport scripts to VM Guest via SCP and exec them via SSH
    #
    # get number of transport files/directories; transport array length
    local __pos=${1}
    shift
    # get transport array; everything to ${__pos}
    local __transport=("${@:1:${__pos}}")
    shift ${__pos}
    # get launch array;
    local __launch=("${@}")

    # check whether VM exist
    if ! __is_present; then
        __log_error "'${_Vm}' doesn't exist"
        return 1
    fi
    # check whether VM is running
    if ! __is_running; then
        __log_error "'${_Vm}' is not running..."
        return 1
    fi

    # checking port forwarding (if no proper rules, try add new one for NAT mapping)
    __fix_ssh_port

    # check whether all pkt can by transported, before starting transporting -
    # - be a bit more atomic
    local __pkt
    for __pkt in "${__transport[@]}"; do
        if [[ -z "${__pkt}" ]] || [[ -d "${__pkt}" ]] || [[ -f "${__pkt}" ]]; then
            continue
        else
            # __pkt is neither file nor directory
            __log_error "${__pkt} is neither file nor directory"
            return 1
        fi
    done

    # complex function shouldn't be check by 'if'; it has big consequence how function definition is processed
    # whole body of function will be executed even error occur (e.g. one of the subfunctions exit with error code 1)
    # I'm aware of this and here it's fine to check __ssh_do_transport
    if ! __ssh_do_transport "${__transport[@]}"; then
        __ssh_do_cleanup "${__transport[@]}"
        return 1
    fi
    __ssh_do_launch "${__launch[@]}"
    __ssh_do_cleanup "${__transport[@]}"
}

# try change ssh_host_port if is used a different than already configured (e.g. env variables where used)
__fix_ssh_port() {
    # port is not setup
    if ! __is_port_present "${ssh_port_name}"; then
        "${_VBoxManage}" controlvm "${_Vm}" natpf1 "${ssh_port_name},tcp,,${ssh_host_port},,${ssh_guest_port}"
        return 0
    fi
    # port is setup, but host port and/or guest port are incorrect
    if ! __is_port_present "${ssh_port_name}.*host port = ${ssh_host_port}.*guest port = ${ssh_guest_port}"; then
        "${_VBoxManage}" controlvm "${_Vm}" natpf1 delete "${ssh_port_name}"
        "${_VBoxManage}" controlvm "${_Vm}" natpf1 "${ssh_port_name},tcp,,${ssh_host_port},,${ssh_guest_port}"
    fi
    # everything is correct - nothing to do.
}

__ssh_do_transport() {
    local __transport=("${@}")
    local __pkt
    # transport scripts to guest
    for __pkt in "${__transport[@]}"; do
        if [[ -z "${__pkt}" ]]; then
            continue
        fi
        __log_info "Scp: ${__pkt}"
        # check whether __pkt is file or dir
        if [[ -d "${__pkt}" ]]; then
            # __pkt is directory
            if [[ ${ssh_keys_enabled} -eq 1 ]]; then
                # create path to ssh private key
                __get_priv_ssh_key
                local __key_path="${ssh_keys_path}/${ssh_priv_key}"
                scp -q -P ${ssh_host_port} -i "${__key_path}" ${ssh_options} -r "${__pkt}" "${ssh_user}@127.0.0.1:~${ssh_user}"
            else
                # 1 mean scp directory (recursive)
                __auto_passwd_scp "${__pkt}" 1
            fi
        elif [[ -f "${__pkt}" ]]; then
            # __pkt is file
            if [[ ${ssh_keys_enabled} -eq 1 ]]; then
                # create path to ssh private key
                __get_priv_ssh_key
                local __key_path="${ssh_keys_path}/${ssh_priv_key}"
                scp -q -P ${ssh_host_port} -i "${__key_path}" ${ssh_options} "${__pkt}" "${ssh_user}@127.0.0.1:~${ssh_user}"
            else
                # 0 mean scp file
                __auto_passwd_scp "${__pkt}" 0
            fi
        fi
        sleep 1
    done
}

__ssh_do_launch() {
    local __launch=("${@}")
    local __cmd
    # run commands via ssh
    for __cmd in "${__launch[@]}"; do
        if [[ -z "${__cmd}" ]]; then
            continue
        fi
        # %HOST% tag - check whether command should be executed on host (not guest)
        if [[ "${__cmd}" =~ ^\ *%HOST% ]]; then
            # extract command
            __cmd=${__cmd//%HOST%/}
            # process defined/template variables
            __cmd=$(__prepare_path "${__cmd}" 0)
            __log_info "Exec (on host): ${__cmd}"
            eval "${__cmd}"
            continue
        fi
        __log_info "Exec: ${__cmd}"
        if [[ ${ssh_keys_enabled} -eq 1 ]]; then
            # create path to ssh private key
            __get_priv_ssh_key
            local __key_path="${ssh_keys_path}/${ssh_priv_key}"
            ssh -q "${ssh_user}@127.0.0.1" -t -i "${__key_path}" -p ${ssh_host_port} ${ssh_options} -C "${__cmd}"
        else
            __auto_passwd_ssh "${__cmd}"
        fi
        sleep 1
    done
}

__ssh_do_cleanup() {
    if [[ ${clean_transported} -eq 0 ]]; then
        return
    fi
    local __transport=("${@}")
    local __pkt
    # clean after scp by rm transported media/scripts
    for __pkt in "${__transport[@]}"; do
        if [[ -z "${__pkt}" ]]; then
            continue
        fi
        __log_info "Clean transported: ${__pkt}"
        local __pkt_to_clean=$(basename "${__pkt}")
        if [[ ${ssh_keys_enabled} -eq 1 ]]; then
            # create path to ssh private key
            __get_priv_ssh_key
            local __key_path="${ssh_keys_path}/${ssh_priv_key}"
            ssh -q "${ssh_user}@127.0.0.1" -t -i "${__key_path}" -p ${ssh_host_port} ${ssh_options} -C "cd ~${ssh_user} && rm -rf ${__pkt_to_clean}"
        else
            __auto_passwd_ssh "cd ~${ssh_user} && rm -rf ${__pkt_to_clean}"
        fi
        sleep 1
    done
}

#@action
_lazy_ssh() {
    # check whether VM exist
    if ! __is_present; then
        __log_error "'${_Vm}' doesn't exist"
        exit 1
    fi
    # check whether VM is running
    if ! __is_running; then
        __log_error "'${_Vm}' is not running..."
        exit 1
    fi
    # load vm description/definition
    local __definition_fname="${1:-}"
    __load_definition "${__definition_fname}"

    __fix_ssh_port
    if [[ ${ssh_keys_enabled} -eq 1 ]]; then
        # create path to ssh private key
        __get_priv_ssh_key
        local __key_path="${ssh_keys_path}/${ssh_priv_key}"
        ssh -q "${ssh_user}@127.0.0.1" -t -i "${__key_path}" -p ${ssh_host_port} ${ssh_options}
    else
        __auto_passwd_ssh ""
    fi
    exit 0
}

__auto_passwd_ssh() {
    local __cmd="${1}"
    if command -v expect >/dev/null 2>&1; then
        if [[ -z "${__cmd}" ]]; then
            # No cmd to exec, interactive shell
            local __expect_cmd="ssh -q \"${ssh_user}@127.0.0.1\" -t -p ${ssh_host_port} ${ssh_options}"
        else
            local __expect_cmd="ssh -q \"${ssh_user}@127.0.0.1\" -t -p ${ssh_host_port} ${ssh_options} -C \"${__cmd}\""
        fi
        expect -c "log_user 0; spawn ${__expect_cmd}; expect password; send \"${ssh_password}\r\"; interact; catch wait reason; exit [lindex \$reason 3]"
    else
        __log_warning "'expect' command not exist - install 'expect (tcl)' to automate ssh authentication without ssh_key."
        __log_warning "To use ssh_key authentication setup ssh_keys_enabled=1 in your definition file."
        # Process without expect
        if [[ -z "${__cmd}" ]]; then
            # No cmd to exec, interactive shell
            ssh -q "${ssh_user}@127.0.0.1" -t -p ${ssh_host_port} ${ssh_options}
        else
            ssh -q "${ssh_user}@127.0.0.1" -t -p ${ssh_host_port} ${ssh_options} -C "${__cmd}"
        fi
    fi
}

__auto_passwd_scp() {
    local __src="${1}"
    local __recursive="${2}"
    if command -v expect >/dev/null 2>&1; then
        if [[ ${__recursive} -eq 1 ]]; then
            local __expect_cmd="scp -q -P ${ssh_host_port} ${ssh_options} -r \"${__src}\" \"${ssh_user}@127.0.0.1:~${ssh_user}\""
        else
            local __expect_cmd="scp -q -P ${ssh_host_port} ${ssh_options} \"${__src}\" \"${ssh_user}@127.0.0.1:~${ssh_user}\""
        fi
        expect -c "log_user 0; spawn ${__expect_cmd}; expect password; send \"${ssh_password}\r\"; expect eof; catch wait reason; exit [lindex \$reason 3]"
    else
        __log_warning "'expect' command not exist - install 'expect (tcl)' to automate ssh authentication without ssh_key."
        __log_warning "To use ssh_key authentication setup ssh_keys_enabled=1 in your definition file."
        # Process without expect
        if [[ ${__recursive} -eq 1 ]]; then
            scp -q -P ${ssh_host_port} ${ssh_options} -r "${__src}" "${ssh_user}@127.0.0.1:~${ssh_user}"
        else
            scp -q -P ${ssh_host_port} ${ssh_options} "${__src}" "${ssh_user}@127.0.0.1:~${ssh_user}"
        fi
    fi
}

#@action
_make_clone(){
    # check whether VM exist
    if ! __is_present; then
        __log_error "'${_Vm}' doesn't exist"
        exit 1
    fi

    if __is_alive; then
        __log_error "'${_Vm}' is alive. VM must be shut down to create clone."
        exit 1
    fi

    # check whether clone_name is provided and take the snapshot with this name
    if [[ -n "${1:-}" ]]; then
        local __clone_name="${1:-}"
        if __is_present "${__clone_name}"; then
            __log_error "'${__clone_name}' already exists."
            exit 1
        fi
    # clone_name is not provided, make the clone with auto generate name - {VM}-clone{NR++}
    elif __is_present "\"${_Vm}-clone[0-9]\+\""; then
        # clone are numered, e.g.: vm_name:aa22-snap-aa11 -> clone_name:aa22-snap-aa11-snap1..999..
        # get all clones match our clone pattern, extract NR value from each clonename, get the highes NR
        local __last_clone_nr=$("${_VBoxManage}" list vms | cut -f 1 -d'{' | grep "\"${_Vm}-clone[0-9][0-9]*\""\
            | sed "s/${_Vm}-clone//;s/\"//g" | sort -gu | tail -1)
        __last_clone_nr=$((__last_clone_nr+1))
        local __clone_name="${_Vm}-clone${__last_clone_nr}"
    # clone with the auto generate name doesn't exist, make the first one.
    else
        local __clone_name="${_Vm}-clone1"
    fi
    "${_VBoxManage}" clonevm "${_Vm}" --name "${__clone_name}" --register
    __log_info "'${_Vm}' has been cloned as '${__clone_name}'."
    exit 0
}

#@action
_take_snapshot(){
    # check whether VM exist
    if ! __is_present; then
        __log_error "'${_Vm}' doesn't exist"
        exit 1
    fi

    # check whether snap_name is provided and take the snapshot with this name
    if [[ -n "${1:-}" ]]; then
        # NB: VBox allow make multiple snapshots with the same name, they are identify by UUID
        local __snap_name="${1:-}"
    # snap_name is not provided, take the snapshot with auto generate name - {VM}-snap{NR++}
    elif __is_snapshot_present "\"${_Vm}-snap[0-9]\+\""; then
        # it would be nice to use `date` but it isn't portable between linux/osx/freebsd
        # so that snapshot are numered, e.g.:
        # vm_name:aa22-snap-aa11 -> snap_name:aa22-snap-aa11-snap1..999..
        # get all snapshots match our snap pattern, extract NR value from each snapname, get the highes NR
        local __last_snap_nr=$("${_VBoxManage}" snapshot "${_Vm}" list --machinereadable | grep "^SnapshotName"\
            | cut -d"=" -f 2- | grep "\"${_Vm}-snap[0-9][0-9]*\"" | sed "s/${_Vm}-snap//;s/\"//g" | sort -gu | tail -1)
        __last_snap_nr=$((__last_snap_nr+1))
        local __snap_name="${_Vm}-snap${__last_snap_nr}"
    # snapshot with the auto generate name doesn't exist, make the first one.
    else
        local __snap_name="${_Vm}-snap1"
    fi
    "${_VBoxManage}" snapshot "${_Vm}" take "${__snap_name}" --live
    __log_info "'${__snap_name}' snapshot was taken."
    exit 0
}

#@action
_restore_snapshot(){
    # check whether VM exist
    if ! __is_present; then
        __log_error "'${_Vm}' doesn't exist"
        exit 1
    fi

    if ! __has_snapshots; then
        __log_error "No snapshots found for the '${_Vm}'"
        exit 1
    fi

    if __is_alive; then
        __log_error "'${_Vm}' is alive. VM must be shut down to restore snapshot."
        exit 1
    fi

    local __snap_name="${1:-}"
    # check whether snap_name is provided and delete the requested snap_name
    if [[ -n "${__snap_name}" ]]; then
        if ! __is_snapshot_present "\"${__snap_name}\""; then
            __log_error "'${__snap_name}' snapshot doesn't exist for the '${_Vm}'"
            __log_error "Use vbkick lssnap '${_Vm}' to list all available snapshots."
            exit 1
        fi
        "${_VBoxManage}" snapshot "${_Vm}" restore "${__snap_name}"
        __log_info "'${__snap_name}' snapshot was restored."
        exit 0
    fi
    "${_VBoxManage}" snapshot "${_Vm}" restorecurrent
    __log_info "Current snapshot was restored."
    exit 0
}

#@action
_delete_snapshot(){
    # check whether VM exist
    if ! __is_present; then
        __log_error "'${_Vm}' doesn't exist"
        exit 1
    fi

    if ! __has_snapshots; then
        __log_error "No snapshots found for the '${_Vm}'"
        exit 1
    fi
    local __snap_name="${1:-}"
    # check whether snap_name is provided and delete the requested snap_name
    if [[ -n "${__snap_name}" ]]; then
        if ! __is_snapshot_present "\"${__snap_name}\""; then
            __log_error "'${__snap_name}' snapshot doesn't exist for the '${_Vm}'"
            __log_error "Use \`vbkick lssnap '${_Vm}'\` to list all available snapshots."
            exit 1
        fi
    # snap_name is not provided, remove the current snapshot
    else
        __snap_name=$("${_VBoxManage}" snapshot "${_Vm}" list --machinereadable | grep "^CurrentSnapshotUUID"\
            | cut -d"=" -f 2- | sed 's/"//g')
    fi
    "${_VBoxManage}" snapshot "${_Vm}" delete "${__snap_name}"
    __log_info "'${__snap_name}' snapshot was deleted."
    exit 0
}

#@action
_list_snapshots(){
    # check whether VM exist
    if ! __is_present; then
        __log_error "'${_Vm}' doesn't exist"
        exit 1
    fi

    if ! __has_snapshots; then
        __log_error "No snapshots found for the '${_Vm}'"
        exit 1
    fi
    "${_VBoxManage}" snapshot "${_Vm}" list
    exit 0
}

__start_web_server() {
    # Do not start webserver - remote server is used instead to serve kickstart files.
    if [[ ${webserver_disabled} -eq 1 ]]; then
        return
    fi
    # check whether port is not used by other proc
    __check_port_usage ${kickstart_port} "kickstart"
    # start simple webserver serving files in background
    vbhttp.pm ${kickstart_port} &
    # get the pid already spawned process, to kill it later
    _web_pid=$!
    # update _webserver_state variable
    _webserver_state=1
    sleep 2
    # check whether web server was really started
    if ! __is_port_used ${kickstart_port}; then
        __log_error "webserver was not started"
        if kill -s 0 ${_web_pid} 2>/dev/null; then
            kill ${_web_pid}
        fi
        _webserver_state=0
        return 1
    fi
    __log_info "webserver has been started (pid ${_web_pid})"
}

__stop_web_server() {
    # check whether webserver is running
    if [[ ${_webserver_state} -eq 0 ]]; then
        return
    fi
    __log_info "Stopping webserver (pid ${_web_pid})"
    # with "set -e -E" if kill command fail then ERR trap is processing
    # simply execution of function is not continued
    _webserver_kill_cmd_state=1
    # check whether process exist and accept signals before sending SIGTERM
    if kill -s 0 ${_web_pid} 2>/dev/null; then
        kill ${_web_pid}
    fi
    _webserver_kill_cmd_state=0
    # update _webserver_state variable
    _webserver_state=0
    # kill command is sucessfull when SIGTERM is sent to running process
    # not when child process was really killed
    if ! ps -ef | grep "vbhttp.pm ${kickstart_port}" | grep -v grep > /dev/null; then
        __log_info "webserver was stopped"
    else
        __log_warning "problem with stopping webserver. Kill process manually"
        ps -ef | grep "vbhttp.pm ${kickstart_port}" | grep -v grep
    fi
}

# (signals and error handler) - cleaning after ctr-c, etc.
#@special
_clean_up() {
    __log_info "Signal handler - cleanup before exiting..."
    # run _on_exit function to make real cleaning
    exit 1
}

#@special
_on_exit(){
    # this is a finally block - exec always on exit
    if [[ ${_webserver_kill_cmd_state} -eq 0 ]]; then
        # stop webserver (only if __stop_web_server function didn't fail previuosly)
        __stop_web_server
    else
        # previuosly executed __stop_web_server function fail in killing $_web_pid
        __log_warning "problem with killing webserver (proc ${_web_pid}). Kill process manually."
    fi
    # clean _tmp_dir if exist
    if [[ -d "${_tmp_dir}" ]]; then
        rm -rf "${_tmp_dir}"
    fi
    # help recover some changes made on VM during exporting
    __recover_vm_state
}

#@special
_main() {
    local __args_num=$#
    # virtual machine name
    _Vm=""
    # VBoxManage binary, by default VBoxManage but could be change via VBOX_MANAGE_PATH env variable.
    _VBoxManage="${VBOX_MANAGE_PATH:-VBoxManage}"
    if [[ ${__args_num} -eq 1 ]]; then
        # check whether we have everything to start with vbkick
        __dependencies_check
        _process_1_args "${1}"
    elif [[ ${__args_num} -eq 2 ]] || [[ ${__args_num} -eq 3 ]]; then
        # check whether we have everything to start with vbkick
        __dependencies_check
        _vb_version=$(__get_vb_version)
        _process_2_args "${1}" "${2}" "${3:-}"
    else
        # wrong number of arguments
        _usage
        exit 1
    fi
}

## MAIN ##
# signals and errors handler
trap _clean_up SIGHUP SIGINT SIGTERM ERR
trap _on_exit EXIT

__init_global_state_variables
if [[ $# -eq 0 ]]; then
    # no arguments
    _usage
    exit 1
fi
_main "${@}"
